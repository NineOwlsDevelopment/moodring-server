import { expect } from "chai";
import axios from "axios";
import { describe, it, before } from "mocha";
import { Keypair } from "@solana/web3.js";
import FormData from "form-data";
import fs from "fs";
import path from "path";
import {
  API_BASE,
  loadWallet,
  authenticateWithWallet,
  createAuthenticatedClient,
  checkDatabaseMigrated,
  sleep,
} from "./helpers/testHelpers";

const wallet = loadWallet();
const USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

/**
 * Advanced exploit tests for liquidity pool operations
 * These tests specifically target potential vulnerabilities:
 * - Rounding errors in share calculations
 * - Race conditions in concurrent operations
 * - Fee distribution exploits
 * - Share dilution attacks
 * - Front-running vulnerabilities
 */
describe("Liquidity Pool Exploit Tests", function () {
  this.timeout(1000 * 60 * 20); // 20 minutes for comprehensive exploit testing

  let cookie = "";
  let client: ReturnType<typeof createAuthenticatedClient>;
  let marketId = "";
  let optionId1 = "";
  let optionId2 = "";
  let isMigrated = false;

  before(async () => {
    isMigrated = await checkDatabaseMigrated();
    if (!isMigrated) {
      console.log("⚠️ Database not migrated, skipping exploit tests");
      return;
    }

    const auth = await authenticateWithWallet(wallet);
    cookie = auth.cookie;
    client = createAuthenticatedClient(cookie);

    await createTestMarket();
  });

  async function createTestMarket() {
    const form = new FormData();
    const base = Keypair.generate().publicKey.toBase58();

    form.append("base", base);
    form.append("marketQuestion", `Exploit Test Market ${Date.now()}`);
    form.append("marketDescription", "Testing for exploits");
    form.append(
      "marketExpirationDate",
      (Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60).toString()
    );
    form.append("usdcMint", USDC_MINT);
    form.append("isBinary", "false");
    form.append("resolvers", wallet.publicKey.toBase58());
    form.append("requiredVotes", "1");
    form.append("resolverReward", "100");

    const imagePath = path.join(__dirname, "asset", "saints.png");
    if (fs.existsSync(imagePath)) {
      const imageBuffer = fs.readFileSync(imagePath);
      form.append("image", imageBuffer, {
        filename: "saints.png",
        contentType: "image/png",
      });
    }

    const createResponse = await client.post("/market/create", form, {
      headers: {
        ...form.getHeaders(),
      },
    });

    if (createResponse.status === 200) {
      marketId = createResponse.data.market;

      const form1 = new FormData();
      form1.append("market", marketId);
      form1.append("optionLabel", "Yes");
      const option1Response = await client.post(
        "/market/option/create",
        form1,
        {
          headers: {
            ...form1.getHeaders(),
          },
        }
      );
      if (option1Response.status === 200) {
        optionId1 = option1Response.data.option;
      }

      const form2 = new FormData();
      form2.append("market", marketId);
      form2.append("optionLabel", "No");
      const option2Response = await client.post(
        "/market/option/create",
        form2,
        {
          headers: {
            ...form2.getHeaders(),
          },
        }
      );
      if (option2Response.status === 200) {
        optionId2 = option2Response.data.option;
      }

      const initResponse = await client.post("/market/initialize", {
        market: marketId,
      });

      if (initResponse.status === 200 || initResponse.status === 409) {
        console.log("✅ Created test market for exploit testing");
      }
    }
  }

  describe("Share Calculation Exploits", () => {
    it("should prevent integer overflow in share calculations", async () => {
      if (!isMigrated || !marketId) return;

      // Try to cause overflow with very large numbers
      const largeAmount = Number.MAX_SAFE_INTEGER;

      const response = await client.post("/liquidity/add", {
        market: marketId,
        amount: largeAmount,
      });

      // Should reject or handle gracefully
      expect(response.status).to.be.oneOf([400, 500]);
    });

    it("should prevent precision loss in share calculations", async () => {
      if (!isMigrated || !marketId) return;

      // Get current state
      const marketResponse = await client.get(`/market/${marketId}`);
      if (marketResponse.status !== 200) return;

      const market = marketResponse.data.market;
      const liquidity = Number(market.shared_pool_liquidity || 0);
      const shares = Number(market.total_shared_lp_shares || 0);

      if (liquidity === 0 || shares === 0) return;

      // Test with amounts that might cause precision issues
      const testAmounts = [
        1_000_000.5, // Should be rounded
        9_999_999.999, // High precision
        10_000_000.0001, // Just above threshold
      ];

      for (const amount of testAmounts) {
        const response = await client.post("/liquidity/add", {
          market: marketId,
          amount: Math.floor(amount),
        });

        if (response.status === 200) {
          const mintedShares = response.data.shares_minted;
          const expectedShares = Math.floor(
            (Math.floor(amount) * shares) / liquidity
          );

          // Should match expected calculation
          expect(mintedShares).to.equal(expectedShares);
        }
      }
    });

    it("should prevent share calculation manipulation via timing", async () => {
      if (!isMigrated || !marketId) return;

      // Get initial state
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const liquidityBefore = Number(marketBefore.shared_pool_liquidity || 0);
      const sharesBefore = Number(marketBefore.total_shared_lp_shares || 0);

      if (liquidityBefore === 0 || sharesBefore === 0) return;

      // Rapidly add liquidity and trade to try to exploit timing
      const depositAmount = 1_000_000; // 1 USDC

      // Start both operations nearly simultaneously
      const [addResponse, tradeResponse] = await Promise.all([
        client.post("/liquidity/add", {
          market: marketId,
          amount: depositAmount,
        }),
        client.post("/trade/buy", {
          market: marketId,
          option: optionId1,
          buyYes: 500_000,
        }),
      ]);

      // Get final state
      const marketAfterResponse = await client.get(`/market/${marketId}`);
      if (marketAfterResponse.status === 200) {
        const marketAfter = marketAfterResponse.data.market;
        const liquidityAfter = Number(marketAfter.shared_pool_liquidity || 0);
        const sharesAfter = Number(marketAfter.total_shared_lp_shares || 0);

        // Pool should be in consistent state
        expect(liquidityAfter).to.be.greaterThan(0);
        expect(sharesAfter).to.be.greaterThan(0);

        // Share value should be reasonable
        if (sharesAfter > 0) {
          const shareValue = liquidityAfter / sharesAfter;
          expect(shareValue).to.be.greaterThan(0);
          expect(shareValue).to.be.lessThan(10);
        }
      }
    });
  });

  describe("Fee Distribution Exploits", () => {
    it("should prevent fee calculation exploits", async () => {
      if (!isMigrated || !marketId || !optionId1) return;

      // Get initial fee state
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const initialFees = Number(marketBefore.accumulated_lp_fees || 0);

      // Make a trade
      const tradeResponse = await client.post("/trade/buy", {
        market: marketId,
        option: optionId1,
        buyYes: 1_000_000,
      });

      if (tradeResponse.status === 200) {
        // Get updated fees
        const marketAfterResponse = await client.get(`/market/${marketId}`);
        if (marketAfterResponse.status === 200) {
          const marketAfter = marketAfterResponse.data.market;
          const newFees = Number(marketAfter.accumulated_lp_fees || 0);

          // Fees should have increased
          expect(newFees).to.be.greaterThanOrEqual(initialFees);

          // Calculate expected fee (assuming 1% LP fee rate)
          const rawCost = Number(tradeResponse.data.trade?.cost || 0);
          const expectedFeeIncrease = Math.floor((rawCost * 100) / 10000); // 1% = 100 bps

          // Actual fee increase should be close to expected
          const feeIncrease = newFees - initialFees;
          expect(feeIncrease).to.be.closeTo(expectedFeeIncrease, 10); // Allow small rounding
        }
      }
    });

    it("should prevent fee accumulation exploits with rapid trades", async () => {
      if (!isMigrated || !marketId || !optionId1) return;

      // Get initial state
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const initialFees = Number(marketBefore.accumulated_lp_fees || 0);

      // Make rapid small trades
      const rapidTrades = Array(10)
        .fill(null)
        .map(() =>
          client.post("/trade/buy", {
            market: marketId,
            option: optionId1,
            buyYes: 100_000, // Small trades
          })
        );

      const responses = await Promise.all(rapidTrades);

      // Get final state
      const marketAfterResponse = await client.get(`/market/${marketId}`);
      if (marketAfterResponse.status === 200) {
        const marketAfter = marketAfterResponse.data.market;
        const finalFees = Number(marketAfter.accumulated_lp_fees || 0);

        // Fees should have increased
        expect(finalFees).to.be.greaterThanOrEqual(initialFees);

        // Fee increase should be reasonable
        const feeIncrease = finalFees - initialFees;
        expect(feeIncrease).to.be.greaterThan(0);
      }
    });
  });

  describe("Pool Liquidity Exploits", () => {
    it("should prevent liquidity pool manipulation", async () => {
      if (!isMigrated || !marketId) return;

      // Get initial state
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const liquidityBefore = Number(marketBefore.shared_pool_liquidity || 0);
      const sharesBefore = Number(marketBefore.total_shared_lp_shares || 0);

      if (liquidityBefore === 0 || sharesBefore === 0) return;

      const shareValueBefore = liquidityBefore / sharesBefore;

      // Add liquidity
      const depositAmount = 10_000_000; // 10 USDC
      const addResponse = await client.post("/liquidity/add", {
        market: marketId,
        amount: depositAmount,
      });

      if (addResponse.status === 200) {
        // Get updated state
        const marketAfterResponse = await client.get(`/market/${marketId}`);
        if (marketAfterResponse.status === 200) {
          const marketAfter = marketAfterResponse.data.market;
          const liquidityAfter = Number(marketAfter.shared_pool_liquidity || 0);
          const sharesAfter = Number(marketAfter.total_shared_lp_shares || 0);

          const shareValueAfter = liquidityAfter / sharesAfter;

          // Share value should not decrease
          expect(shareValueAfter).to.be.greaterThanOrEqual(shareValueBefore);

          // New liquidity should equal old + deposit
          expect(liquidityAfter).to.equal(liquidityBefore + depositAmount);
        }
      }
    });

    it("should prevent negative liquidity exploits", async () => {
      if (!isMigrated || !marketId) return;

      // Try to manipulate liquidity to go negative
      const marketResponse = await client.get(`/market/${marketId}`);
      if (marketResponse.status !== 200) return;

      const market = marketResponse.data.market;
      const liquidity = Number(market.shared_pool_liquidity || 0);

      // Pool should never have negative liquidity
      expect(liquidity).to.be.greaterThanOrEqual(0);
    });
  });

  describe("Race Condition Exploits", () => {
    it("should prevent double-spending in concurrent liquidity additions", async () => {
      if (!isMigrated || !marketId) return;

      // Get initial state
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const liquidityBefore = Number(marketBefore.shared_pool_liquidity || 0);
      const sharesBefore = Number(marketBefore.total_shared_lp_shares || 0);

      // Attempt concurrent identical deposits
      const depositAmount = 1_000_000; // 1 USDC
      const concurrentDeposits = Array(5)
        .fill(null)
        .map(() =>
          client.post("/liquidity/add", {
            market: marketId,
            amount: depositAmount,
          })
        );

      const responses = await Promise.all(concurrentDeposits);

      // Get final state
      const marketAfterResponse = await client.get(`/market/${marketId}`);
      if (marketAfterResponse.status === 200) {
        const marketAfter = marketAfterResponse.data.market;
        const liquidityAfter = Number(marketAfter.shared_pool_liquidity || 0);
        const sharesAfter = Number(marketAfter.total_shared_lp_shares || 0);

        // Calculate expected changes
        const successfulDeposits = responses.filter((r) => r.status === 200);
        const expectedLiquidityIncrease =
          successfulDeposits.length * depositAmount;

        // Actual increase should match expected
        const actualIncrease = liquidityAfter - liquidityBefore;
        expect(actualIncrease).to.be.lessThanOrEqual(
          expectedLiquidityIncrease + 1000
        ); // Allow small rounding

        // Shares should be consistent
        if (liquidityAfter > 0 && sharesAfter > 0) {
          const shareValue = liquidityAfter / sharesAfter;
          expect(shareValue).to.be.greaterThan(0);
        }
      }
    });

    it("should prevent race conditions between trades and liquidity operations", async () => {
      if (!isMigrated || !marketId || !optionId1) return;

      // Get initial state
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const liquidityBefore = Number(marketBefore.shared_pool_liquidity || 0);
      const sharesBefore = Number(marketBefore.total_shared_lp_shares || 0);

      // Concurrent trade and liquidity addition
      const [tradeResponse, addResponse] = await Promise.all([
        client.post("/trade/buy", {
          market: marketId,
          option: optionId1,
          buyYes: 1_000_000,
        }),
        client.post("/liquidity/add", {
          market: marketId,
          amount: 5_000_000,
        }),
      ]);

      // Get final state
      const marketAfterResponse = await client.get(`/market/${marketId}`);
      if (marketAfterResponse.status === 200) {
        const marketAfter = marketAfterResponse.data.market;
        const liquidityAfter = Number(marketAfter.shared_pool_liquidity || 0);
        const sharesAfter = Number(marketAfter.total_shared_lp_shares || 0);

        // Pool should be in consistent state
        expect(liquidityAfter).to.be.greaterThan(0);
        expect(sharesAfter).to.be.greaterThan(0);

        // Share value should be reasonable
        if (sharesAfter > 0) {
          const shareValue = liquidityAfter / sharesAfter;
          expect(shareValue).to.be.greaterThan(0);
          expect(shareValue).to.be.lessThan(10);
        }
      }
    });
  });

  describe("Boundary Condition Exploits", () => {
    it("should handle edge case: deposit exactly equal to pool liquidity", async () => {
      if (!isMigrated || !marketId) return;

      // Get current pool state
      const marketResponse = await client.get(`/market/${marketId}`);
      if (marketResponse.status !== 200) return;

      const market = marketResponse.data.market;
      const liquidity = Number(market.shared_pool_liquidity || 0);
      const shares = Number(market.total_shared_lp_shares || 0);

      if (liquidity === 0 || shares === 0) return;

      // Deposit exactly equal to current liquidity
      const response = await client.post("/liquidity/add", {
        market: marketId,
        amount: liquidity,
      });

      if (response.status === 200) {
        // Should get shares equal to current shares (doubling the pool)
        expect(response.data.shares_minted).to.equal(shares);
        expect(response.data.new_pool_liquidity).to.equal(liquidity * 2);
      }
    });

    it("should handle edge case: very small pool with large deposit", async () => {
      if (!isMigrated || !marketId) return;

      // This test would require creating a new market with minimal liquidity
      // For now, we'll test the calculation logic
      const marketResponse = await client.get(`/market/${marketId}`);
      if (marketResponse.status !== 200) return;

      const market = marketResponse.data.market;
      const liquidity = Number(market.shared_pool_liquidity || 0);
      const shares = Number(market.total_shared_lp_shares || 0);

      if (liquidity === 0 || shares === 0) return;

      // Large deposit relative to pool
      const largeDeposit = liquidity * 10;

      const response = await client.post("/liquidity/add", {
        market: marketId,
        amount: largeDeposit,
      });

      if (response.status === 200) {
        const expectedShares = Math.floor((largeDeposit * shares) / liquidity);
        expect(response.data.shares_minted).to.equal(expectedShares);
      }
    });

    it("should prevent division by zero in share calculations", async () => {
      if (!isMigrated || !marketId) return;

      // This is handled by the 1:1 ratio for empty pools
      // But let's verify the system handles it correctly
      const marketResponse = await client.get(`/market/${marketId}`);
      if (marketResponse.status !== 200) return;

      const market = marketResponse.data.market;
      const liquidity = Number(market.shared_pool_liquidity || 0);
      const shares = Number(market.total_shared_lp_shares || 0);

      // Pool should never have zero liquidity with non-zero shares
      if (shares > 0) {
        expect(liquidity).to.be.greaterThan(0);
      }
    });
  });

  describe("Mathematical Invariant Tests", () => {
    it("should maintain invariant: shares * shareValue ≈ liquidity + fees", async () => {
      if (!isMigrated || !marketId) return;

      const marketResponse = await client.get(`/market/${marketId}`);
      if (marketResponse.status !== 200) return;

      const market = marketResponse.data.market;
      const liquidity = Number(market.shared_pool_liquidity || 0);
      const fees = Number(market.accumulated_lp_fees || 0);
      const shares = Number(market.total_shared_lp_shares || 0);

      if (shares === 0) return;

      const totalValue = liquidity + fees;
      const shareValue = totalValue / shares;

      // Get share value from API
      const shareValueResponse = await client.get(
        `/liquidity/share-value/${marketId}`
      );

      if (shareValueResponse.status === 200) {
        const apiShareValue = Number(
          shareValueResponse.data.value_per_share || 0
        );

        // Should match our calculation
        expect(apiShareValue).to.be.closeTo(shareValue, 0.01);
      }
    });

    it("should maintain invariant: share value never decreases on deposit", async () => {
      if (!isMigrated || !marketId) return;

      // Get initial share value
      const marketBeforeResponse = await client.get(`/market/${marketId}`);
      if (marketBeforeResponse.status !== 200) return;

      const marketBefore = marketBeforeResponse.data.market;
      const liquidityBefore = Number(marketBefore.shared_pool_liquidity || 0);
      const feesBefore = Number(marketBefore.accumulated_lp_fees || 0);
      const sharesBefore = Number(marketBefore.total_shared_lp_shares || 0);

      if (sharesBefore === 0) return;

      const shareValueBefore = (liquidityBefore + feesBefore) / sharesBefore;

      // Add liquidity
      const depositAmount = 5_000_000;
      const addResponse = await client.post("/liquidity/add", {
        market: marketId,
        amount: depositAmount,
      });

      if (addResponse.status === 200) {
        // Get updated share value
        const marketAfterResponse = await client.get(`/market/${marketId}`);
        if (marketAfterResponse.status === 200) {
          const marketAfter = marketAfterResponse.data.market;
          const liquidityAfter = Number(marketAfter.shared_pool_liquidity || 0);
          const feesAfter = Number(marketAfter.accumulated_lp_fees || 0);
          const sharesAfter = Number(marketAfter.total_shared_lp_shares || 0);

          const shareValueAfter = (liquidityAfter + feesAfter) / sharesAfter;

          // Share value should not decrease
          expect(shareValueAfter).to.be.greaterThanOrEqual(shareValueBefore);
        }
      }
    });
  });
});
